
== Maps

А вот и наш любимчик map(отображения), идея проста, есть ключ, тогда есть и значение(как логин и пароль, или как индекс и значение по данному индексу).

Но в map ключом может быть и строка, и число, и любой другой тип, при этом необязательно последовательный. 

Устройство Отображений таково:
  + У нас есть Хэш-функция
  + Передав в Хэш-функцию ключ, мы получаем число, взяв остаток от числа(некоторого n, это либо capacity, либо size) получим номер бакета (ячейки памяти, куда в дальнейшем и будем складывать наши ключи со значениями, если бакет переполнится, то произойдет рехэширование) 

В STL имеется две структуры как и в случае со множествами:
  - map, основан на сбалансированном двоичном дереве со временем доступа O(log n).
  - unordered_map, в основе которого лежит техника хэширования со средним временем доступа к элементам O(1).

Приступим к примерам:

#rect(
  ```cpp
  map<string, int> m;
  m["monkey"] = 4;
  m["banana"] = 3;
  m["harpsichord"] = 9;
  cout << m["banana"] << "\n"; // 3
  ```
)

Если в map такого ключа нет, то он создастся и в него запишется заданное значение.

При простом обращении к элементу по несуществующему ключу, помимо создания ключа, будет присвоено значение по умолчанию. Например, в следующем коде в отображение
добавляется ключ "aybabtu" со значением 0.

#rect(
  ```cpp
  map<string, int> m;
  cout << m["aybabtu"] << "\n"; // 0
  ```
  )
)

Функция count проверяет, существует ли ключ в отображении:

#rect(
  ```cpp
  if (m.count("aybabtu")) {
    // работаем с ключом
  }
  ```
)

А так можно напечатать все ключи и значения отображения:
#rect(
  ```cpp
  for (auto x : m) {
    cout << x.first << " " << x.second << "\n";
  }
  ```
)


