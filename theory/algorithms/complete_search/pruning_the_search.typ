
== Pruning the search

Рассмотрим задачу, в которой нужно посчитать всевозможные пути в клетке n*n клеток с верхнего левого в правый нижний углы, посетив каждую клетку 1 раз. Например, для 7*7 есть 111712 путей. Оставим сетку 7*7.

#figure(
  image("../../images/grid1.png", width: 25%),
)
  
*Basic algorithm*

Ничего сложного, просто берем backtrack и все.
  -  время работы: 483 секунды
  - количество рекурсивных вызовов: 76 миллиардов

*Optimization 1*

В каждом решении мы сначала идем либо вправо, либо вниз, а значит всегда есть два пути симметричных друг другу относительно диагонали. То есть, мы имеем право выбрать куда идти на первой итерации и умножить на 2 полученный результат.

#figure(
  image("../../images/grid2.png", width: 60%),
)  
- running time: 244 секунды
- количество рекурсивных вызовов: 38 млрд

*Optimization 2*

Если путь достигает нижнего правого угла, не посетив все остальные клетки, то очевидно что дальше рассчитывать ничего не нужно.

#figure(
  image("../../images/grid3.png", width: 25%),
)

- running time: 119 секунд
- количество рекурсивных вызовов: 20 млрд

*Optimization 3*

Модернизируем предыдущий способ, если "змея" достигла стены и может повернуть и вправо, и влево, то заполнить все клетки невозможно.

#figure(
  image("../../images/grid4.png", width: 25%),
)

- running time: 1.8 секунд
- количество рекурсивных вызовов: 221 миллион

*Optimization 4*

А идея прошлой оптимизации в свою очередь может быть модернизирована еще больше, например, если "змея" может повернуть либо вправо, либо влево но не может идти прямо, то достичь всех клеток невозможно.

#figure(
  image("../../images/grid5.png", width: 25%),
)

- running time: 0.6 секунд
- количество рекурсивных вызовов: 69 млн

Вдумайтесь было: 483 секунды, 76 млрд
стало: 0.6 секунд, 69 млн
выигрыш: 805, 1101,45

В общем суть вы уловили, надо срубать самые корневые ответвления и наш алгоритм будет бесподобен.
