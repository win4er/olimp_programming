== Coin Problem

Дано множество монет: coins = {c1, с2,  с3, … сk} и цель собрать заданный номинал за минимальное количество монет. 

Жадный алгоритм как мы помним справлялся отлично, но только в редких случаях, например в монетах евро стандарта. Поэтому жадный алгоритм не создавал оптимальное решение.

Теперь же самое время решить задачу эффективно, используя динамическое программирование. Алгоритм динамического программирования основан на рекурсивной функции, которая идет через всевозможные варианты как собрать эту сумму(как с брутфорсом). Но эффективность этого алгоритма в мемоизации и просчитывании ответа на каждую подзадачу только ОДИН раз.

*Recursive formulation*

Идея динамического программирования это сформулировать задачу рекурсивно, что позволит решить задачу, решив маленькие подзадачи(разделяй и властвуй). В случае нашей задачи, рекурсивная формулировка такова: какое наименьшее количество монет необходимо для данной суммы.

Возьмем монеты coins = {1, 3, 4}, первые значения функции таковы:

```
  solve(0) = 0
  solve(1) = 1
  solve(2) = 2
  solve(3) = 1
  solve(4) = 1
  solve(5) = 2
  solve(6) = 2
  solve(7) = 2
  solve(8) = 2
  solve(9) = 3
  solve(10) = 3
```
            
Как вы могли догадаться функция в общем имеет вид:
  $ "solve(x)" = cases(
    infinity & "if" x<0,
    0 & "if" x=0,
    min_(c in "coins")"solve(x-c)"+1 & "if" x>0
    ) $
      
Если x < 0, то решить задачу невозможно, если же x=0, 0 монет будет достаточно, а для x>0 применяем рекурсию и находим минимальное количество монет.

#rect(
  ```cpp
  int solve(int x) {
    if (x < 0) return INF;
    if (x == 0) return 0;
    int best = INF;
    for (auto c : coins) {
      best = min(best, solve(x-c)+1);
    }
    return best;
  }
  ```
)

Но эта функция все еще не эффективна.

#pagebreak()
*Using memoization*

Идея динамического программирования это использование _мемоизации_ для эффективного вычисления значений рекурсивной функции. Это и значит, что значения функции хранятся в массиве после их вычисления.

#rect(
  ```cpp
  bool ready[N];
  int value[N];

  int solve(int x) return INF:
    if (x == 0) return 0;
    if (ready[x]) return value[x];
    int best = INF;
    for (auto c : coins) {
      best = min(best, solve(x-c)+1);
    }
    value[x] = best;
    ready[x] = true;
    return best;
  ```
)

Аcимптотическая сложность: O(nk), n-target sum, k-coins. 
Но при всем этом мы могли написать код так(не уч отриц значения):

#rect(
  ```cpp
  value[0] = 0;
  for (int x=1; x<=n; x++) {
    value[x] = INF;
    for (auto c : coins) {
      if (x-c >= 0) {
        value[x] = min(value[x], value[x-c]+1);
      }
    }
  }
  ```
)

На деле, большинство соревновательных программистов предпочитают именно этот код, тк он меньше и имеет ниже константный фактор(че). Но думать о алгоритмах динамического программирования проще в рекурсии.

*Constructing a solution*

В предыдущих главах мы уже описывали процесс создания оптимального решения. В случае с coin problem, мы можем объявить другой массив, который для каждой суммы монет хранит первую монету в оптимальном решении.

#rect(
  ```cpp
  int first[N];
  value[0] = 0;
  for (int x = 1; x <= n; x++) {
    value[x] = INF;
    for (auto c : coins) {
      if (x-c >= 0 && value[x-c]+1 < value[x]) {
        value[x] = value[x-c]+1;
        first[x] = c;
      }
    }
  }
  ```
)

Теперь код может быть использован для вывода оптимального решения для заданного n.

*Counting the number of solutions*

Let us now consider another version of the coin problem where our task is to calculate the total number of ways to produce a sum x using the coins. For example, if coins = {1,3,4} and x=5, there are a total of 6 ways:

#table(
  align: center,
  columns: 2,
  [1+1+1+1+1], [3+1+1],
  [1+1+3], [1+4],
  [1+3+1], [4+1],
)
Снова мы можем решить задачу рекурсивно. Пусть solve(x) обозначает число способов всех получения заданной суммы x.
Прошлый пример уже показывал все варианты, а само решение ничуть не ново:

$ "solve(x)" = "solve(x-1) + solve(x-3) + solve(x-4)" $
          
Ну, а теперь доведем до ума решение, чтобы оно работало всегда.

$ "solve(x)" = cases(
  
  0 & "if" x < 0,
  1 & "if" x = 0,
  sum_(c in "coins")"solve(x-c)" & "if" x > 0
) $
      
Объяснять нечего, сами все видите, теперь код:


Забегая вперед, что-то похожее мы увидим в задаче о рюкзаке.
Часто число решений столь велико, что не требуется высчитывать конкретное число, но при этом достаточно дать ответ по модулю m, где, например, $m=10^9 + 7$. Этого можно достичь следующим образом:

Сейчас все идеи динамического программирования были обсуждены, приступим к демонстрации на задачах, чтобы увидеть возможности ДП.
