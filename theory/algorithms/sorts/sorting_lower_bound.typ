
== Sorting Lower Bound

Реально ли достичь сортировки быстрее чем $O(n log n)$?
Это невозможно, если сортировка основана на сравнении элементов.

Нижняя граница временной сложности может быть доказана рассмотрением сортировки как процесса, где каждое сравнение двух элементов дает больше информации о содержимом массива:

#rect(
  figure(
    image("../../images/lower_bound2.png", width: 80%),
    caption: "Схема работы сортировок на основе сравнения",
  )
)
#rect(
  figure(
    image("../../images/lower_bound1.png", width: 80%),
    caption: "Общая схема работы сортировок на основе сравнения",
  )
)

"$x < y?$" означает сравнение некоторых элементов x и y, верное утверждение отправляет в левую ветку, иначе в правую.

Значит у каждого узла именно 2 потомка(тоже узла). Т.к. на вход мы получаем массив из n элементов, то количество возможных массивов равно кол-ву его различных перестановок - n!, а тогда количество листьев дерева не менее n!

_(в противном случае некоторые перестановки были бы не достижимы из корня, а значит, алгоритм неправильно работал бы на некоторых исходных данных)._

Т.к двоичное дерево высоты(глубины) h имеет не более $2^h$ листьев имеем: 

$ n! <= l <= 2^h, $
где l число листьев.
Тогда получим, что высота дерева не менее:
$ log_2(n!) = log_2(1) + log_2(2) + ... + log_2(n). $
Несложно доказать оценку:
$ log_2(n!)>=(n/2)* $
И наконец получаем:
$ n/2 * log_2(n/2) = n/2 (log_2(n)-1)=Omega(n log(n))  $

#show link: underline
#link("https://neerc.ifmo.ru/wiki/index.php?title=%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%BE_%D0%BD%D0%B8%D0%B6%D0%BD%D0%B5%D0%B9_%D0%BE%D1%86%D0%B5%D0%BD%D0%BA%D0%B5_%D0%B4%D0%BB%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8_%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8")[Доп. источник]