
== Bubble Sort

Пузырьковая сортировка это самый простой и популярный сортировочный алгоритм, который работает за $O(n^2)$. Логика проста: у нас есть n раундов и на каждом из них алгоритм сравнивает два последовательных элемента, если они в неправильном порядке, то их меняют местами.

#figure(
  rect[
    #image("../../images/bubble_sort.png", width: 80%)
  ],
  caption: "Схема работы Bubble Sort"
)

#pagebreak()
*Реализация*
#rect(
  ```cpp
  for (int i=0; i<n; ++i) {
    for (int j=0; j<n; ++j) {
      // по возрастанию
      if (array[j] > array[j+1]) {
        swap(array[j], array[j+1]);
      }
    }
  }
  ```
)

Таким образом после первой операции самый большой элемент окажется на правильном месте, в общем говоря, после k раундов, k-наибольших элементов будут на правильных местах. Так что после n операций весь массив будет отсортирован.

=== Пара слов про анализ сложности

Также для анализа сложности алгоритма сортировки удобно использовать _инверсии_

$ (a, b) : a < b  "и array[a] > array[b]" $

То есть такие пары чисел (вообще-то это транспозиции), у которых индексы идут по возрастанию, а сами числа не соответствуют возрастанию.

#align(
  center,
  table(
    //align: center,
    columns: 8,
    stroke: (x, y) => (
      left: if x * y > 0 { 0.8pt },
      top: if y > 0 { 0.8pt },
      bottom: if y > 0 { 0.8pt },
    ),
    [0], [1], [2], [3], [4], [5], [6], [7],
    [1], [2], [2], [6], [3], [5], [9], [8],
  ),
)
#align(
  center,
  "инверсии: (3, 4), (3, 5) и (6, 7)"
)

Число инверсий показывает сколько работы нужно для сортировки массива, то есть массив отсортирован тогда, когда инверсий не осталось. С другой стороны массив чисел по убыванию содержит максимальное количество инверсий:

$ 1 + 2 + ... + (n-1) = n(n-1)/2 = O(n^2), $

Очевидно, что swap от последовательных элементов неправильного порядка удаляет только 1 инверсию, поэтому остальные инверсии остаются, а сложность алгоритма все также $O(n^2)$.
